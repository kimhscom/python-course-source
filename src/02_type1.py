# 02_type1.py

# 자료형 (data type)
#  - 숫자, 문자열, 리스트,튜플, 딕셔너리, 집합, bool
#  - 파이썬에서 자료(값)를 다루는 형태들

'''
    1. 숫자 (number)
        정수       : -123, 0, 123 (음수/0/양수)
        실수(소수) : -3.14, 3.14 (소수점 존재)
        2진수      : 0b10, 0B10    (10진수 2)
        8진수      : 0o10, 0O10    (10진수 8)
        16진수     : 0x10, 0X10    (10진수 16)
            > shell 에 특정 진수의 값을 입력하면 10진수로 가르쳐준다. (계산기)

        사칙연산 : +, -, *, /
        제곱연산 : **
        몫연산   : //
        나머지연산 : %
'''
print("[1. 숫자]")
print("정수 :", -123, 0, 123)
print("실수 :", -3.14, 3.14)
print("2진수 :", 0b10)
print("8진수 :", 0o10)
print("16진수 :", 0x10)
# bin(), oct(), hex()
print( "123을 2진수로 :", bin(123) )
print()

print("[숫자 연산하기]")
num1 = 10
num2 = 3
# [num1 = 10, num2 = 3]
print( "[num1 = ", num1, ", num2 = ", num2, "]", sep="" )
print("num1 + num2 =", (num1+num2))
# 내가 의도하는 연산은 꼭! 소괄호() 로 묶어준다.
# 안 그러면 '연산자 우선순위'를 공부해야한다...
print("num1 - num2 =", (num1-num2))
print("num1 * num2 =", (num1*num2))
print("num1 / num2 =", (num1/num2)) # 3.3333... 무한소수 : 정해진 자리 수
# 컴퓨터는 0,1 밖에 모르고 bit를 가지고 값을 표현
# 32bit,64bit
# 1byte =8bit
# 완벽한 소수 표현이 불가능 --> 근사값
#   > 소수를 이용한 정확한 연산이 필요하다 => 검색!
print("num1 ** num2 =", (num1**num2))
print("num1 // num2 =", (num1//num2))
print("num1 % num2 =", (num1%num2))

# 나머지 연산은 상당히 자주 사용되고, 잘 활용하면 유용하다!
#   ex1) num % 3 나머지 값이 0이면, num은 3의 배수이다.
#   ex2) num % 2 나머지 값이 0이면, num은 짝수이다. ( 0 제외 )
print()

'''
    2. 문자열 (string)
        "abcd"
        '1234'
            -> 따옴표로 묶으면 문자열!

        문자열을 만드는 방법
            1. 작은 따옴표
            2. 큰 따옴표
            3. 작은 따옴표 3개 연속
            4. 큰 따옴표 3개 연속

        이스케이프 문자
            - 문자열 안에서 특수한 기능을 가지는 문자
            - 역슬래시(\)와 뒤따라오는 글자가 합쳐져서 기능이 생김
                \n  개행 (줄바꿈) new line
                \t  tab키 만큼 여백 발생 (공백처럼) - 정렬 할 때 사용
                \\  \ 하나 사용
                \"  " 하나 사용
                \'  ' 하나 사용
'''
print("[2. 문자열]")
print("[문자열을 만드는 4가지 방법]")
print('happy day')
print("happy day")
print('''happy day''')
print("""happy day""")
# 모두 똑같은 문자열!
# 그럼 왜? 4개씩이나?

# (1) 문자열 안에서 사용하고 싶은 따옴표 기호가 겹칠 때
# 김철수 "파이썬 재밌다!"
#print("김철수 "파이썬 재밌다!"") # 오류! 문자열이 분리돼버린다.
print('김철수 "파이썬 재밌다!"')   # 해결1
print("김철수 \"파이썬 재밌다!\"") # 해결2 - 익숙해지기만 하면 이게 좋은 방법
# 반대의 경우도 동일!

# (2) 문자열에서 여러 줄을 사용하고 싶을 때
# 철수 "파이썬 재밌니?"
# 영희 "응 재밌어~~"
print("""철수 \"파이썬 재밌니?\"
      영희 \"응 재밌어~~\"""")
print("철수 \"파이썬 재밌니?\"\n영희 \"응 재밌어~~\"")
# 따옴표 3개짜리는 엔터쳐서 여러 줄을 표현할 수 있다.

# 이스케이프 문자를 이용하면 따옴표에 관계없이 문자를 표현할 수 있다!
print()

# 문자열과 여러 줄 주석의 관계
print("[문자열과 주석]")
import sys

str1 = '''안녕1''' # 문자열을 변수에 대입
'''안녕2''' # 마치 주석처럼 써놓기만한 문자열
# 한번 읽기만 하고 사용되지 않았기 때문에 값이 따로 만들어지지 않는다.

print("안녕1 count :", sys.getrefcount('''안녕1'''))
print("안녕2 count :", sys.getrefcount('''안녕2'''))

# 여러 줄 문자열은 프로그램 사용에 영향 없다.
# 만약 변수에 대입하거나 출력 등을 하면 그땐 영향이 있다.
print()

'''
    문자열 연산하기
        + 덧셈 : 글자 연결
        * 곱셈 : 글자 반복
'''
print("[문자열 연산]")
print("안녕"+"하세요")
str1 = "안녕"
str2 = "하세요"
str3 = str1 + str2 # 하나의 값(연결된 문자열)이 만들어졌기 때문에 str3에 대입 가능
print(str3)

print(str1 * 3)
str4 = str1* 5 # 동일하다. (연산 후 값 생성 -> 대입)
print(str4)
print()
print("=" * 20)
print("문자열 연산하기")
print("====================")
print()

# 인덱싱과 슬라이싱

'''
    문자열 인덱싱
        인덱싱(indexing) : index는 색인. 무언가를 가리킨다.
        문자열은 하나 하나의 문자가 나열된 값 -> 순서가 존재
        (중요) 순서를 0부터 센다.
            인덱스라는 용어 들어가면 무조건 0부터!
'''
print("[문자열 인덱싱]")

# 서두리지도 말고, 쉬지도 말고 - 괴테
my_str = "Without haste, but without rest." # 32글자

print(my_str)
print(my_str[0] + my_str[1]) # 문자열을 인덱싱하면 결과는 문자열 (그래서 + 연결 가능)
print(my_str[-1]) # 음수는 뒤에서부터 순서를 센다.
# (참고) C, JAVA 등에선 인덱스에 음수 사용 불가능 (정석)

# 원래는 마지막 글자를 인덱싱하고 싶으면, 전체 글자 개수를 알아야한다.
#print(my_str[32]) # 오류! 32는 33번째 글자 = 없는 글자
print(my_str[32-1]) # 마지막 글자 = 전체길이 -1
print(my_str[-32]) # 뒤에서부터 -1 이니까 이건 정상
#print(my_str[-33]) # 오류! 마찬가지로 범위 초과
print()

# 문자열의 성질 (1) : 문자열은 '하나의 요소'가 하나의 문자, 순서 존재, 인덱싱 가능

'''
    문자열 슬라이싱
        슬라이싱(slicing) : 조각낸다
        인덱스를 이용하여 범위를 지정하여 여러 글자를 뽑아낸다.

        a[0:3]   -->  콜론(:)으로 범위 지정

        a[시작인덱스:끝인덱스]  --> 끝인덱스의 값은 뽑지 않는다.

        a[시작인덱스:]   --> 시작인덱스 부터 '끝'까지
        a[:끝인덱스]     --> '시작' 부터 끝인덱스까지 (끝인덱스 포함 X)
        a[:]            --> '시작' 부터 '끝'까지 (전체) -> 사용X
'''
print("[문자열 인덱싱]")
# 서두리지도 말고, 쉬지도 말고 - 괴테
my_str = "Without haste, but without rest." # 32글자

print(my_str[0] + my_str[1] +my_str[2] + my_str[3]) # 불편!
print(my_str[0:4] ) # 편함 (인덱스4 값은 뽑지않음)

print( my_str[8:13] ) # 0부터 시작할 필요 없음
print( my_str[0:100] ) # 범위가 초과해도 오류 X (자동으로 끝까지)
print( my_str[8:] ) # 8부터 끝까지
print( my_str[:6] ) # 시작부터 5까지 (6은 포함X)
print( my_str[:-7] ) # 시작부터 뒤에서 7번째가지. (-7은 포함X)
print( my_str[:-100] ) # 시작부터 뒤에서 100번째가지 (글자 없음)

# 기존 문자열의 글자를 변경하고 싶다!
# ex) my_str의 첫 글자를 소문자 w 로 변경하고 싶어요~~
#my_str[0] = 'w' # 오류! - 변경 불가능한 성질

# 새로운 문자열을 만들어야만 한다.
new_str = 'w' + my_str[1:]
print(new_str)

# 문자열의 성질 (2) : 한번 만들어진 문자열은 절대로 변경할 수 없다.
#   > 이와 유사한 성질을 가진 자료형 : 튜플
print()

# 포매팅은 앞으로 문자열을 만들 때(특히 출력할 때) 많이 사용할 것.(편함)
'''
    문자열 포매팅
        - 대상이 되는 문자열에 값을 삽입하는 것
        - 문자열 안의 값이 계속 변해야할 때
          문자열 안에 들어갈 변수의 값이 여러 개일 때

          (1) 기본 포매팅 : 문자열 뒤에 % 기호를 사용
          (2) 포매팅 함수 : 문자열.format()

          - 우리는 앞으로 포매팅 함수를 사용할 것!
'''
print("문자열 포매팅 함수")
name = "한수창"
age = 20

# 제 이름은 한수창이고, 나이는 20살 입니다.
print("제 이름은 " + name + "이고, 나이는" + str(age) + "살 입니다.")
print("제 이름은 " + name + "이고, 나이는", age,  "살 입니다.", sep='')

#print( "".format()) # fortmat() 함수 사용 시 여기서부터 시작
# (1) 대상문자열인 큰 따옴표에 글자들을 입력
#
# (2) format()의 소괄호 안에, 삽입될 값들을 입력
# *** 중괄호의 개수와 값의 개수를 맞춰준다.
#     값의 성질(자료형)에 관계 없이 다 삽입 가능

print( "제 이름은 {}이고, 나이는 {}살 입니다.".format(name, age))

age += 1 # age = age + 1 완벽하게 동일
# 복합 대입연산자 : 대입연산자(=)와 다른 연산자가 합쳐진 것
# +=, -=, *=, /=, %= 등등 다 원리 동일

# += 연산은 원래의 값에 뒤에 값을 '누적'하는 용도로 많이 사용
print( "01 제 이름은 {}이고, 나이는 {}살 입니다.".format(name, age))

# {} 안에 넣는 정수 : index (뒤에 있는 값을 가져오는 순서를 명시)
#  > 01 처럼 인덱스 적지 않으면 자동으로 0부터 부여된다.
print( "02 제 이름은 {0}이고, 나이는 {1}살 입니다.".format(name, age))
print( "03 제 이름은 {1}이고, 나이는 {0}살 입니다.".format(name, age))

# {} 안에 넣는 단어 : keyword 
print( "04 제 이름은 {name}이고, 나이는 {age}살 입니다.".format(name=name, age=age))
# name=name
# keyword=값(변수이름)

# 키워드로 정확하게 값이 들어갈 위치를 명시하기 때문에, 순서를 지킬 필요가 없다.
print( "04 제 이름은 {n}이고, 나이는 {a}살 입니다.".format( a=age, n=name ))

# 그냥 인덱스, 키워드 이런거 사용하지말고 기본으로 사용하세요.
# [num1 = 10, num2 = 3]
num1 = 10
num2 = 3
print( "[num1 = ", num1, ", num2 = ", num2, "]", sep="" )
print("[num1 = {}, num2 = {}]".format(num1,num2))

# "".format()은 print()함수와 아무런 관련이 없다.
a = "{}".format("안녕")
print(a)

print()

# 소수를 삽입할 때 '소수점' 지정
print( "파이 = {:.3f}".format(3.141592)) # 소수점(.) 3번째 자리까지
print( "파이 = {0:.3f}".format(3.141592)) # 인데스 혼용 가능
# 인덱스나 키워드 뒤에 콜론(:)을 붙여서 옵션을 사용
print()

# 내용 정렬
print("[{}] [{}]".format("파이썬", "재밌다" ))
# 인덱스 생략 {0:10} {1:10}
print("[{:10}] [{:10}]".format("파이썬", "재밌다" )) # 최소 자리수 지정 (좌측정렬)
print("[{:>10}] [{:>10}]".format("파이썬", "재밌다" )) # 우측정렬
print("[{:<10}] [{:<10}]".format("파이썬", "재밌다" )) # 좌측정렬
print("[{:^10}] [{:^10}]".format("파이썬", "재밌다" )) # 가운데정렬

print("[{:하^10}] [{:호^10}]".format("파이썬", "재밌다" )) # 빈 공간에 '한 글자'

# 파이썬에서 (다른언어도 마찬가지) 기본으로 적용되는 것들이 많다.
# print() -->sep='' , end='\n'
# "".format()
# {} -> 인덱스가 자동으로 0부터
# <  -> 기본이 좌측정렬
# 공백 -> 정렬 시 자동으로 빈 공간은 공백이 채워진다.
print()

print("[문자열 관련 함수들]")
# "".format() 으로 사용했던 것처럼, '문자열'을 이용해서 사용하는 함수들
# (format도 문자열 함수)

str1 = "I'm a Boy"

# upper() : 문자열의 모든 영문자를 대문자로 변환
print( str1.upper() ) # str1 문자열을 '이용'해서 새로운 대문자로 된 문자열을 만들어 돌려졌다.
# str1 문자열 자체는 변하지 않는다. (함수 기능을 위해 글자들이 사용만 된 것)
print( str1 ) 

'''
함수는 그 목적에 따라
    1) 기능 수행의 결과 값을 되돌려주는 경우가 있고,
    2) 기능 수행만 하고 결과 값이 없는 경우가 있다.

문자열은 변하지 않는 성질이기 때문에, 대부분 새로운 문자열을 만들어서 되돌려준다.
'''

# lower() : 소문자로
str2 = str1.lower()
print(str2)

# title() : 영단어의 첫 글자를 대문자로
str3 = "python python"
print( str3.title() ) # 만들어지는 새로운 문자열을 print()에서 바로 출력
print( str3 )
print()

# strip() : 좌우측 공백 제거
str4 = "           공 백 제 거          "
print(str4)
print( str4.strip() ) # 공백이 아닌 문자를 만날때까지만 제거

print( "           공 백 제 거          ".rstrip() ) # right
 
# join() : 특정 문자열("A")을 대상 문자열("BBB")에 삽입 (해서 새로운 문자열 만듦)
print( "A".join("BBB") )
print()

# replace("A", "B") : 문자열 안의 모든 "A"를 찾아서 "B"로 변경
str5 = "문자열 대체하기(replace) : python python"
# str5에서 python의 p를 대문자로 만든 새로운 문자열을 만들자!
#str6 = str5.replace( "p", "P" ) # replace 도 된다.
str6 = str5.replace( "py", "Py" ) # 변경하고 싶은 글자를 특정 지을 수 있는 최소범위
print(str6)
print()

# 여기서부터는 결과 값이 문자열이 아닌, 함수들

# count("A") : 문자열 안의 모든 "A"의 개수를 가르쳐준다. (결과 값이 정수)
print("str5에서 python의 개수 :", str5.count("python"))
# str5는 replace() 했지만 그대로 있다. (변경된 문자열은 str6에 대입)
# 찾는 문자열이 없으면 0

# split("A") : 문자열을 특정 문자("A") '기준'으로 나눈다.
str7 = "문자열 나누기(split)"
print( str7.split("나")) # 결과는 '리스트'
print( "ㅋ ㅋ ㅋ ㅋ ㅋ".split() ) # 기준 문자열을 넣지 않으면, 공백, 개행 등 여백이 기준

# index("A") : 문자열에서 "A"를 찾고, 그 위치(index)를 가르쳐준다. (반환/돌려줌)
print( "ABCABC".index("B") ) # 처음 찾은 글자의 위치
print( "ABCABC".index("CAB") ) # 첫번째 글자의 위치
#print( "ABCABC".index("D") ) # 오류! 없으면 오류

# 꼭 index를 사용해서 값을 찾아야 한다면, count() 함수와 조합!
a = "ABC"
if a.count("B") > 0 : # a 문자열에서 "B"의 개수가 0보다 크면,(1개 이상이면)
    print( "a에서 B의 위치 :", a.index("B") )
else :
    print( "없다." )

# find("A") : index()와 동일, 없으면 -1
print( "ABCABC".find("D") )

print( "ABCABC".rindex("B") ) # reverse (뒤집다) : 뒤에서부터 찾음 (rfind도 존재)
print( "ABCABC".index("B", 2) ) # 2번 인덱스부터 찾기 시작 (find도 동일)
