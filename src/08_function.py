# 08_function.py

'''
    [함수 function]     (method 메서드 : 같은 말)
      - 특정 작업을 수행하는 일련의 문장들을 하나로 묶은 것!

      - 함수의 장점 (사용하는 이유)
          1. 한 번 만들어놓으면 언제든지 재사용 가능
          2. 중복된 코드 제거
          3. 프로그램의 구조화
              > 작업 단위로 코드를 묶어서 구조화 시킨다.

[함수의 기본 구조]
def 함수이름(매개변수) :             def = define 정의한다
    수행문
    return 반환 값 (또는 결과 값)

1. 매개변수 (parameter)
    - (필요 시) 함수가 호출될 때 값을 받을 '변수'
        > 호출이 될 때마다 새로 만들어지고, 호출이 끝나면 바로 제거 (항상 새 변수가 만들어진다)
        > 이러한 매개변수는 이 함수의 '지역변수'이다. (이 함수 안에서만 사용이 가능)
    - 개수 제한이 없고, 필요 없으면 생략도 가능
    - 우리가 함수를 호출할 때 전달하는 '값'을 인수라고 부른다.
        > argument

2. 반환 값 (결과 값)
    - return 뒤에 오는 값은, 함수의 수행이 완료되고 되돌려주는 값
    - 'return' 을 사용하면 함수의 수행이 끝난다.
        > 마치 반복문에서 break를 사용한 것과 느낌이 비슷!!

    >>> 매개변수와 반환 값의 유/무에 따른 함수 형태 (4가지)
          1. 매개변수와 반환 값이 둘 다 있다.
          2. 매개변수와 반환 값이 둘 다 없다. (기능 수행만 한다.)
          3. 매개변수만 있다.
          4. 반환 값만 있다.
      > 이 4가지 형태 중, 어떤 형태로 함수를 만들 것인가?
        만드는 함수의 목적에 따라 알아서 결정
'''
#print( "f(5) =", f(5) ) # 오류! 아직 정의되지 않은 함수

# f(x) = x + 5 를 파이썬으로 만들어서 사용해보기
def f(x) :      # def -> 정의한다 -> 변수 만드는 것과 비슷
    return (x+5)

# f(x)는 매개변수와 반환 값, 둘 다 존재하는 함수의 형태
#   x             매개변수 (parameter)
#   return (x+5)  반환 값 (return value)

# 이런 매개변수나 반환 값을 둘 다 사용하는게 일반적이긴한데,
# 필요 없으면 사용하지 않아도 된다! (함수의 목적에 따라 결정)

print( "f(5) =", f(5) )   # f(x) 함수에 전달하는 정수5는 argument(인수/인자)
print( "f(10) =", f(10) ) # 정수10도 argument
# 이 전달하는 값을 받을 수 있는 (저장/대입하는) 변수가 매개변수 x (parameter)

print()
print("[함수의 4가지 형태]")
# 1. 매개변수와 반환 값이 둘 다 없는 함수
def say_ho() :
    print("ho~~!")
    print("ho~~! ho~~!")

say_ho() # 함수의 사용 (호출)
print("say_ho() 호출 후!")
say_ho()
print("끝!")

print()
# 2. 매개변수만 있고, 반환 값이 없는 함수
def say( talk ) :
    print( "공지 : {}".format(talk) )

say( "파이썬 수업 중 입니다." )
say( 100 )
#say() # 오류! 매개변수에 대입될 전달 값이 부족
#say(1, 2) # 오류! 전달 값이 너무 많다.
print()

# 3. 매개변수는 없고, 반환 값이 있는 함수
def get_ho() :
    print("문자열을 돌려줍니다! 들고가세요!")
    return "ho! ho!"

get_ho() # return에 의해 반환된 값은 꼭 사용해야 하는건 아니다.

# 그렇지만, 반환 되었기 때문에 이 값을 사용할 수 있다.
# > 함수가 값을 반환하다 = 반환이 목적인 함수 = 그 값을 사용하는게 일반적

print("11111")
result = get_ho() # 호출1
print("반환 값 :" + result)
print("22222")
print("반환 값 :" + get_ho() ) # 호출2
print("33333")

# 호출1 : 반환된 값을 변수에 대입하는 용도로 사용
#          > 변수에 값이 대입됐기 때문에, 계속해서 반환값을 다룰 수 있다.
# 호출2 : 반환된 값을 print() 안에서 문자열과 + 하는 용도로 사용
#          > 1회용


# 반환 값이 없는 <함수의 호출 코드>를 사용하려 한다면? (호출1, 호출2처럼)
#  > say_ho() 반환 값 없었음!
print( "반환 값이 없는 함수 say_ho() :", say_ho() )
result = say_ho()
print(result)

# 반환되는 값이 없는데 사용하면, 값이 없는걸 의미하는 None이 사용된다.
#   > (참고) 다른 언어에서는 반환 값이 없으면 애초에 사용을 못함! (오류)


print()

# 4. 매개변수와 반환 값이 둘 다 있다.
#  매개변수가 있다 = 개수에 맞게 값을 전달해야한다. (규칙)
#  반환 값이 있다  = 반환된 값을 사용할 수 있다. (선택)
def add(num1, num2) :
    print("삐리리릿! {}, {} 의 덧셈 결과를 돌려드립니다.".format(num1, num2))
    return (num1+num2)

print( add(10, 20) )   # 반환 값을 바로 출력 (사용)
result = add(100, 200) # 반환 값을 변수에 대입 (사용)
print( result )


# 궁극적인 함수 사용 이유!
#  > 중복되는 코드를 줄이고, 관리를 편하게 하기 위해서!

# ex) 사람 1명의 정보를 출력하려할 때, 정보가 3개면 3줄 사용! (5개면 5줄)
print("이름 :", "한수창")
print("나이:", 20)
print("번호 :", "010-1234-1234")

print("이름 :", "홍길동")
print("나이:", 40)
print("번호 :", "010-4321-4321")

# 함수로 만든다면, 변경되는 값만 '매개변수'로 전달 받아서 처리!
def print_info( name, age, phone ) :
    print("이름 :", name+"님")
    print("나이:", age)
    print("번호 :", phone)

print_info("이몽룡", 21, "112")
print_info("성춘향", 20, "114")
print_info("임꺽정", 30, "119")

# 보통은 여러 줄의 코드가 2~3번 이상 반복적으로 쓰이면, 함수로 만드는게 낫다!
print()

'''
    사칙연산 함수 4개 정의하고, 결과 출력하기
        1. 함수 4개는 미리 정의해준다.
        2. 공통 : 함수는 매개변수가 2개 (연산할 값 2개를 전달 받는다.)
        3. 반환 값 유/무
            덧셈,뺄셈   : 연산의 결과 값을 반환 --> 반환 값을 이용해서 결과를 밖에서 출력
            곱셈,나눗셈 : 연산의 결과 값을 반환하지 않고, 함수 안에서 바로 출력

        [출력결과]
            10 + 3 = 13
            10 - 3 = 7
            30 * 3= 30
            10 / 3 = 3.33
'''
# 덧셈,뺄셈은 연산의 결과 값을 '반환'한다.
def my_add(a, b) :
    return (a+b)

def my_min(a, b) :
    return (a-b)

# 곱셈,나눗셈은 값을 반환하지 않고 함수에서 바로 출력한다.
def my_mul(a, b) :
    print("{} * {} = {}".format(a, b, (a*b)))

def my_div(a, b) :
    print("{} / {} = {:.2f}".format(a, b, (a/b)))

# 여기서부터 함수를 사용하는 코드 작성
num1 = 10
num2 = 3

# 덧셈, 뺄셈 -> 결과 값이 반환된다. (함수에서 출력X) -> 결과 받아서 여기서 출력
result = my_add(num1, num2)
print("{} + {} = {}".format(num1, num2, result))
print("{} - {} = {}".format(num1, num2, my_min(num1, num2)))

# 곱셈, 나눗셈 -> 반환 값이 없다 -> 단독적으로 호출만 한다. (함수에서 결과출력)
my_mul(num1, num2)
my_div(num1, num2)


print()

###################################################
# 여기서부턴 파이썬에서 함수를 다루는 skill          #
###################################################

# 함수에서 여러 개의 값 반환하기 --> 거짓말
#  > 모든 함수는 반환 값이 '없거나', 1개 (여러 개일 수 없다.)
#  > (참고) C,JAVA 등의 언어에선 return 뒤에 콤마로 나열 불가능
print("[여러 값 반환]")

def calc(a, b) :
    return a+b, a-b, a*b, a/b # 괄호 생략하고 나열하면 튜플!

print( calc(10, 5) )

a = calc(10, 3)
print(a)
a, b, c, d = calc(20, 4) # ( 24, 16, 80, 5.0 ) 결과값 반환
print(c)

print()

# 매개변수에 초기값 넣기 - 함수 만들 때! (미리 만들어놓는 사람이 하는 일)
print("[매개변수 초기값]")
#print_info("홍길동", 20) # 오류! 매개변수(parameter)에 대입될 값(argument)이 부족

def print_info( name, age, phone="010-xxxx-xxxx" ) :
    print("이름 :", name)
    print("나이:", age)
    print("번호 :", phone)

# 초기값이 지정된 매개변수에 값을 안 줘도 된다.
print_info("홍길동", 20)        # 값을 안 주면, 초기값 적용
print_info("임꺽정", 30, "119") # 값을 주면, 내가 준 값 적용
print()

# 키워드 인수 : 함수 호출 시 매개변수를 키워드로 사용 - 함수를 사용하는 사람의 skill
print_info(age=25, phone="112", name="성춘향")
# 순서가 상관 없다. (정확히 매개변수명을 지정)

# 우리가 사용했던 함수들 중에, 매개변수 초기값과 키워드 인수를 사용했던 함수?!
#   > print() 함수! sep=' ', end='\n' 이게 지금 매개변수에 적용된 초기값
#     우리는 필요에 따라 print(1,2,sep='') 형태로 키워드 인수로써 값을 적용했었다!

print()

# 매개변수로 전달될 값이 몇 개인지 모를 때(그때그때 다를때) : 가변인수 *args

# 3개, 4개, 5개의 덧셈 결과를 함수에서 구하고 싶다면?
def add( *args ) : # arguments
    # 여러 개의 값을 *찍은 변수에 대입하는 것 : 패킹(packing)
    # 패킹된 (*args) 변수에서 * 떼고 사용하면 튜플 : 언패킹(unpacking)
    #print(args) # 튜플!

    result = 0
    for i in args : # args는 튜플이니까 i에는 요소가 하나씩 대입되면서 수행
        result += i
    return result

print( add(1,2) )
print( add(1,2,3) )
print( add(1,2,3,4,5) )

# 가변인수가 사용된 함수?
#   > print() 도 몇 개의 값을 나열해도 잘 출력된다~!
print()

# 함수는 호출하면, 코드의 흐름이 '점프'했다가, 수행이 끝나고 '원래위치'로 돌아온다.
def func3() :# 9
    print("func3() 시작") # 10
    print("func3() 끝") # 11

def func2() : # 6
    print("func2() 시작") # 7
    func3() # 8, 12 - 반환 값이 있었다면, 그 값을 사용하는 행위를 해야한다.
    print("func2() 끝") # 13

def func1() : # 3 매개변수가 있었다면, 값을 대입하는 행위가 필요하다
    print("func1() 시작") # 4
    func2() # 5, 14
    print("func1() 끝") # 15

# 함수 정의 끝
print("func1() 호출 전") # 1
func1() # 2, 16
print("func1() 호출 후") # 17
    
print()

# 재귀함수 (recursive function)
#  - 함수의 수행문 코드에서 '나 자기 자신' 함수를 다시 호출하는 함수
#  - 나 자기 자신 함수를 다시 호출하는 행위 : 재귀호출(recursive call)
#  - 반복문과 성격이 유사하다. (너무 많이 반복하면 오류난다.)

#  - 너무 많은 반복은 오류가 발생했었다!
#  - 함수는 호출될 때 stack(스택) 이라는 메모리 공간을 사용한다.
#     > Stack : First In, Last Out (FILO)  : 출입구 1개 (우물형태)
#     > Queue : First In, First Out (FIFO) : 출입구 2개
#     > 스택이 가득찼을 때 오류가 발생! --> Stack Overflow (스택 메모리 초과)

#     > 스택을 사용하는 이유?
#       >> 돌아가야할 위치를 기억하기 위해!

#  - 재귀함수는 스택을 사용하기, 때문에, (추가/삭제) 반복문보다 속도가 느리다.
#     > 가급적 재귀함수는 사용하지 않는다.
#     > 반복문보다 확실한 이득(코드가 간결해지거나..)이 있을 때 사용하는걸 '고려'

def func(n) :
    print("func() 시작, n =", n) # 3, 4, 5
    if n == 1 :
        print("func()은 n이 1일 때부터 끝!!")
        return # 더 이상 아래 재귀호출을 하지 않고, 함수를 끝낸 뒤 돌아간다.

    func(n-1) # 재귀호출 (날 호출할 때 받은 값에서 1뺀 값으로 다시 호출)
    print("func() 끝, n =", n) # 6, 7
# 함수정의 끝
print("func() 호출 전") # 2
func(3) # 1
print("func() 호출 후") # 8


print()
# 지역변수와 전역변수
#  - 전역변수 : 전체영역에서 사용 가능한 변수 (들여쓰기 없이 만드는 변수들)
#  - 지역변수 : 특정 지역에서만 사용 가능한 변수 (함수 안에서 생성된 변수)

# 파이썬에선 들여쓰기 없는 코드의 위치를 global 이라고 한다.
value = "전역변수"

def f1() :
    print(value)

def f2() :
    value_f2 = "나는 f2의 지역변수!"
    print(value_f2)
    # 만들어진 지역(f2)이 끝나면 자동으로 소멸된다. (삭제)

def f3() :
    #global value # value 전역변수를 새로 만들기
    value = "전역변수 값 변경!" # 이름만 똑같은 지역변수 value가 생성
    print(value)

def f4() :
    global value_f4 # global(전역)에 해당 이름을 등록만 하는 것
    value_f4 = "나는 전역변수가 되고싶어요.."
    print(value_f4)

# 함수 정의 끝
f1()
f2()
#print(value_f2) # 오류! f2()에서만 사용 가능한 f2() 함수의 지역변수
f3()
print("f3()에서 value 변경 후 : " + value)

print()
f4()    # 반드시 f4()를 호출해야 global이 수행된다.
print(value_f4) # f4() 호출하지 않으면, 이 코드는 오류
