# 03_type2.py

'''
    3. 리스트 (list)
        - 관련 있는 데이터들의 목록
        - 상당히 편하다.

        리스트명(변수) = [ 요소1, 요소2, 요소3, ..., 요소N ]

'''
print("[리스트 만들기]")

a = [] # 빈 리스트 (이런식으로 미리 만들어두는 경우가 많다.)
b = [1, 2, 3] # 요소가 정수 3개
c = ["AA", "BB", "CC"] # 문자열 3개
d = [1, "AA", 2, "BB"] # 정수2개, 문자열2 -> 혼합된 리스트
e = [1, "AA", [2, "BB"]] # 혼합된 리스트인데, 리스트를 요소로 가짐 (이중리스트)

# 리스트 안의 요소로 아무거나 다 넣을 수는 있다. (d, e처럼 섞어서)
# 그렇지만 이렇게 만들면 사용할 수 없는 리스트가 된다. (일관성,규칙 X)
# > 반복문 같은 코드에서 사용하려며 '공통된 규칙'이 필요하다!

print(a)
print( type(a) ) # type() : 자료의 타입을 가르쳐준다. (class 용어는 일단 무시)
print(b)
print(c)
print(d)
print(e)

print()

# 리스트도 문자열처럼 여러 요소들이 나열된 자료형이기 때문에,
# 각 요소들에 순서 존재 --> 인덱싱, 슬라이싱 가능
print("리스트 인덱싱, 슬라이싱")

my_list = [10, "10"]
print(my_list[0] * 2) # 첫번째 요소가 '정수'   -> 곱셈
print(my_list[1] * 2) # 두번째 요소가 '문자열' -> 반복
# 문자열을 인덱싱하면, 모든 요소가 문자열이기 때문에 가져온 값은 무조건 '문자열'
# 리스트를 인덱싱하면, 해당 요소의 성질을 그대로 따라간다.

my_list = ["한수창", "홍길동", ["이몽룡", "성춘향"]]
# my_list의 요소는 3개. (세번째 요소가 리스트일 뿐)
print( my_list[2] )       # 리스트!
print( my_list[2][0] )    # 이몽룡 출력
print( my_list[2][0][1] ) # 몽 출력
print()

# 슬라이싱
print( my_list[0:2] ) # 0, 1
print( my_list[0:1] ) # 0

# 리스트를 슬라이싱하면, 결과는 범위가 어떻게 되더라도 무조건 '리스트'
print("[리스트]")
a = [1,2,3]
b = [4,5,6]
c = a + b   # 1) 모든 요소가 합쳐진, (연산!)  2) 새로운 리스트가 생성
print(c)

d = a * 2
print(d)
print()

print("[리스트 수정하기]")
# 문자열은 한 번 만들면 변경할 수 없엇다!

a = [1,2,3,4,5,6]
a[0] = -1 # 리스트는 이게 가능!!
print(a)

#a[0:2] = 0 # 오류! 슬라이싱은 무조건 '리스트'가 결과. 리스트만 대입 가능
a[0:2] = [0] # 0,1 두 요소가 하나의 요소(정수0)로 대체된다.
print(a)

a[0:2] = [7,8,9] # 연속된 범위의 값 수정
print(a)

a[0] = [1,2,3] # 첫번째 요소에 [1,2,3] 리스트로 대체
print(a)
print()

print("[리스트 요소 삭제하기]")
a[0] = [] # 빈 리스트로 대체! (삭제 아님)
print(a)

del( a[0] ) # 첫번째 요소 제거 
print(a)

a[0:2] = [] # 0,1 범위에 넣을 값이 없다 라고 해석 (빈리스트 대입이 아님)
print(a)

del( a[0:2] ) # 0,1 범위 요소 제거 
print(a)

del( a ) # 변수 자체 제거 
#print(a)
print()

print("[리스트 관련 함수들]")

print("[append]")
# append(value) : 리스트 가장 뒤에 요소 추가 (덧붙이다, 첨부하다)
a = [1,2,3]
a.append(4)
print(a)
# 문자열 관련 함수를 사용할 때와 차이점?
#  > 리스트는 변할 수 있는 성질 -> 대상 리스트 자체가 변한다.
#   -> 새로운 리스트를 만들어주는 않는다. -> 함수 수행의 결과 값이 없다.

# 결과값이 없는 함수를 어딘가에 사용하게 되면? (마치 문자열 함수 사용처럼)
print( a.append(5) ) # print()가 출력할 값은 없다. (None)
b = a.append(6) # b에 대입될 값은 없다.
print( b ) # None

# append()가 수행되긴 한다. (단지 결과 값이 없을 뿐)
print( a )

#a.append(7,8) # 오류! 1개의 값만 추가할 수 있다.
a.append([7,8]) # 7,8을 요소로 가진 하나의 리스트가 추가된 것!
print( a )
print()

# clear() : 모든 요소 제거
print("[clear]")
a.clear()
print(a) # clear 후에는 '빈 리스트'

# insert(index,value) : 특정 위치(index)에 value 삽입 (추가)
print("[insert]")
a = [1,2,3]
a.insert(1,0) # 1번 인덱스 위치(두번째)에 정수0을 삽입
print(a)
print()

print("[sort]")
# sort() : 리스트 정렬하기
a = [9, 2,8, 2]
a.sort() # 오름차순 정렬
print(a)

a.sort(reverse=True) # 내림차순 정렬 (오름차순 정렬 후, 뒤집는 것)
print(a)

# sort()와 sorted()
# a.sort()  : a가 주체
# sorted(a) : a는 도구
a = [3, 1, 2]
b = sorted(a)
print(a)
print(b)

a = [8,3,8,3]
b = a #b 변수는 a 리스트를 같이 가리킨다.
b.sort()
print(a)
print()

print("[copy]")
# copy() : 모든 값을 복제하여 새로운 리스트 만듦
a = [1,2,3]
b = a        # a와 b는 똑같은 [1,2,3] 리스트를 가리킨다.
c = a.copy() # [1,2,3] 리스트를 복제하여 새로운 리스트를 만들어서 대입

b[0] = "B"
c[1] = "C"
print(a)
print(c)
print()

print("[reverse]")
# reverse() : 리스트 뒤집기 (정렬 하지 않음)
a = [9, 2, 8, 2]
a.reverse()
print(a)
print()

print("[index]")
# index(value) : 리스트에서 value를 찾고, 위치(index)를 반환
a = [1,2,3,1,2,3]
print( a.index(2) )
#print( a.index(4) ) # 오류! 문자열의 index()와 같다.
print()

print("[count]")
# count(value) : 리스트에서 value의 개수 반환
print("a에서 정수2의 개수 :", a.count(2))
print("a에서 정수4의 개수 :", a.count(4)) # 없으면 0

# count()로 개수가 1개 이상일 때만 index()를 사용한다. (문장에서 정리했던 내용)
print()

print("[remove]")
# remove(value) : 리스트에서 처음 찾은 value 제거
a = [1,2,3,1,2,3]
a.remove(3)
print(a)
#a.remove(10) #오류! index()처럼 없는 값이면 오류 -> count()로 개수 확인 후 사용 

'''
    a[0] = []      -> 첫번째 요소를 '빈 리스트'로 변경
    del(a[0])      -> 첫번째 요소를 제거 (위치를 찾음)
    a.remove(0)    -> a 리스트에서 정수0을 찾아서 제거 (값을 찾음)

    > 값을 찾아서 지울 지, 위치를 찾아서 지울 지는 그때그때 다르다!
'''
print()

print("[pop]")
# pop(index) : 리스트에서 index 위치의 값을 반환, 제거 (뽑아낸다)

# 2가지 기능을 하는 함수
#   (1) 원하는 위치의 값을 제거
#   (2) 지운 값이 함수의 결과 값

a = [1,2,3,4,5,6]
a.pop(3) # 4번째 값을 뽑아내라
print(a)

b = a.pop(2) # 3번째 값을 뽑아내기 + 그 값이 결과값으로 나온다.
print(a)
print(b)
a.pop() # 기본이 -1 (뒤에서 첫번째)
print()

print("[len]")
# len() : 리스트의 함수 아님. 내장함수 --> 요소 개수 구하기
a = "1234abcd"
b = [1,2,3,4,"a","b","c","def"]
print( len(a) ) # 문자의 개수
print( len(b) ) # "def"는 리스트의 8번째 요소 (1개의 값)
print()

# 리스트의 모든 요소가 '문자열'로 이루어져 있을 때!
# 문자열 관련 함수 join()을 이용하여, 새로운 문자열로 만들 수 있다.
my_list = ["대", "한", "민", "국"]

# "A".join("BBB") --> "A"를 "BB" 각 문자 사이사이에 삽입한 새로운 문자열

my_str = "".join(my_list) # join()은 문자열을 만들어주는 함수!
print(my_str)

'''
    4. 튜플 (tuple)
        - 리스트와 거의 똑같다!
        - 차이점
            1. 생성하는 기호
                리스트 []
                튜플   ()      --> 함수 사용하는 기호와 같다. 혼동X

            2. 튜플은 문자열처럼 한 번 만들어지면 변경할 수 없다.(리스트는 변경O)

        - 일반적으로 리스트를 사용! (튜플 잘 사용 안 함)
            > 근데 파이썬에서 이미 튜플을 사용하는 경우가 꽤 있어서 알고는 있어야함
'''
print("[튜플 만들기]")
a = () # 빈 튜플 --> 변경 불가능 --> 이렇게 사용할 일이 없다.
b = (1,) # 요소가 1개일 땐 뒤에 콤마(,)를 붙인다. --> 사용X
c = (1,2,3,"a")
d = 1,2,3 # 소괄호 생략하면 자동으로 '튜플'이 된다.
e = (1,2,(3,4))

print(d)
print( type(d) )

f, g, h = 4, 5, 6 # 좌우측 짝이 맞으면 하나씩 대입, 하나의 변수면 '튜플'이 됨
print(g)

print("[튜플은 변하지 않는다...]")
a = 1,2,3,4,5
#a[0] = 0 # 오류! 튜플 변경 불가! (문자열처럼)
#del( a[0] ) # 오류!

# 튜플 관련 함수는 count(), index() 밖에 없다!

# 인덱싱, 슬라이싱 사용 가능! (변경시키는 행위가 아님)
print( a[1] ) # 두번째 값
print( a[0:1] )
# 리스트를 슬라이싱하면 결과는 리스트였던 것처럼, 튜플도 슬라이싱하면 튜플이다.

# 연산도 가능! (+,* 마찬가지로 변경시키는 행위가 아니라, 새로운 값을 만듦)
a = 1,2,3
b = 4,5,6
c = a+b   # a,b 튜플의 요소를 더한 새로운 튜플 생성!
print(c)
